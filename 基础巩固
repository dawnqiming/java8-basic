基础知识整理
一、Java 空字符串“”和null区别
	1、String = “”，表示声明的是一个字符串类型的空字符串，长度为0，占内存，在内存中分配内存空间的。可以调用Object的方法
	2、String=null,表示声明一个对象的值，空引用。字符串对象的引用，不分配内存地址，调用null类型字符串方法会抛出空指针异常。

例： String str1 = ""; //str1对应一个空串，声明对象的引用
String str2 = null; //str2引用为空
String str3 = new String();//str3将指向具体的String实例，默认值为“”
注意：str1和str3被实例化，而str2没有实例化，但str1和str3所指的地址不同，但值一样，都为空。
null不是对象（空引用），“”是对象，故比较的时候应该是if(str1.equals(""))和if(str2 == null)，也即对象用equals()比较，null用等号比较。正确的写法是先判断是不是对象，如果是，再判断是不是空字符串。
补充说明：1、Java中类的对象都是用句柄来访问的， 类似于C中的指针。
2、Java中有两个判断相等的方法：“==”和equals()方法，前者是根据地址来比较，只有地址和值都相等，这两个变量（引用类型）才相等；后者比较的是变量的值，只要值相等，两者就相等。
3、在Java中变量和引用变量是存在栈中（stack），而对象（new出来的）都是存放在堆中（heap）。
例如：String str = new String("abc");//str存放在stack中，abc这个值存放在heap中，并指向其分配的内存空间。

二、Java中equals和==的区别
==是一个运算符，而equals是String对象的方法，可以.(点)出来的
我们在比较中，无非用的也是这两种方法，1、基本数据类型比较，2、引用对象比较
a)基本数据类型比较：== 和 equals都比较两个值是否相等，相等return true，否则return false
b)引用对象比较：== 和 equals都比较栈内存中的地址是否相等，相等return true，否则return false
特别强调：
1、string是一个特殊的引用类型，对于两个字符串的比较，不管是==还是equals这两者比较的都是字符串是否相同
2、当创建两个string对象时，内存中的地址是不相同的，可以赋相同的值，所以字符串的内容相同，引用的地址不一定相同，也就是说相同内容的对象地址不一定相同，反过来一定相同
1）比较两个字符串对象
String a = new String("zxc");
String b = new String("zxc");
如果用==号比较a和b，则会返回false，因为创建了两个对象，它们在内存中的地址是不一样的
2）equals的情况比较复杂，它是java.lang.object类中的一个方法，因为java中所有的类都默认继承Object，所以所有的类都有这个方法
Object的源码：
 
同样是使用==进行内存地址的比较，但是许多java类都重写了这个方法，比如String
 
String里的方法，如果==比较不相等，还是会比较一下值
所以equals方法具体的作用要看当前的那个类是如何重写父类中该方法的，如果没有重写该方法，那么他和==号等价
补充：
关于offset的使用？
offset显然是一个偏移量的int值。至于多少，我想前面代码应该有获取或者赋值给他。
很明显程序时比较两个字符串的某一部分是否相同。如果offset为0，那么应该是从开始第一个与第二个字符串比较。如果不一致就返回失败。
offset不为0的话，就是从某个中间位置开始与第二个字符串的某个位置开始比较。
123456
456
这两个字符串，offset取一个为3，一个为0，那么比较后会返回真了。就是这个意思。 如果都取0，显然1与4不匹配。而从2位置开始，就是从4开始比较，自然456与456匹配了。
offset就是一个偏移值。就是String里面代表偏移量的一个值

三、静态属性
1、 static是静态修饰符，什么叫静态修饰符呢？大家都知道，在程序中任何变量或者代码都是在编译时由系统自动分配内存来存储的，而所谓静态就是指在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间，也就是只要程序在运行，那么这块内存就会一直存在。这样做有什么意义呢？在Java程序里面，所有的东西都是对象，而对象的抽象就是类，对于一个类而言，如果要使用他的成员，那么普通情况下必须先实例化对象后，通过对象的引用才能够访问这些成员，但是用static修饰的成员可以通过类名加“.”进行直接访问。（静态对象的数据在全局是唯一的，一改都改。如果你想要处理的东西是整个程序中唯一的，弄成静态是个好方法。 非静态的东西你修改以后只是修改了他自己的数据，但是不会影响其他同类对象的数据）


四、Mysql
1、mysql 索引失效的场景
1)、查询时使用 or 可能会导致索引失效，根据 or 左右两边的查询列是否命中相同的索引。所以尽量使用union all 或者 in 查询
2)、 where语句中索引列使用了负向查询，可能会导致索引失效。负向查询包括：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等
3)、索引字段可以为null，使用is null或is not null时，可能会导致索引失效
4）、在索引列上使用内置函数，一定会导致索引失效
5)、隐式类型转换导致的索引失效
6）、隐式字符编码转换导致的索引失效
当两个表之间做关联查询时，如果两个表中关联的字段字符编码不一致的话，MySQL可能会调用CONVERT函数，将不同的字符编码进行隐式转换从而达到统一。作用到关联的字段时，就会导致索引失效。
7）、对索引列进行运算，一定会导致索引失效
8）、like通配符可能会导致索引失效
9)、联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效
10)、MySQL优化器的最终选择，不走索引
优化索引的一些建议
•	禁止在更新十分频繁、区分度不高的属性上建立索引。
•	更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能。
•	“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。
•	建立组合索引，必须把区分度高的字段放在前面。

2、sql优化
2.1查看执行计划：
explain selelct * form emp where name = ‘bob’;
expain出来的信息有10列，分别是id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra：
概要描述：
•	id:选择标识符
•	select_type:表示查询的类型。
•	table:输出结果集的表
•	partitions:匹配的分区
•	type:表示表的连接类型
•	possible_keys:表示查询时，可能使用的索引
•	key:表示实际使用的索引
•	key_len:索引字段的长度
•	ref:列与索引的比较
•	rows:扫描出的行数(估算的行数)
•	filtered:按表条件过滤的行百分比
•	Extra:执行情况的描述和说明
type表示表的连接类型，由上至下，效率越来越高
•	ALL : 全表扫描
•	index : 索引全扫描
•	range : 索引范围扫描，常用语<,<=,>=,between,in等操作
•	ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中
•	eq_ref : 类似ref，区别在于使用的是唯一索引，使用主键的关联查询
•	const/system : 单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询
•	null : MySQL不访问任何表或索引，直接返回结果
虽然上至下，效率越来越高，但是根据cost模型，假设有两个索引idx1(a, b, c),idx2(a, c)，SQL为"select * from t where a = 1 and b in (1, 2) order by c";如果走idx1，那么是type为range，如果走idx2，那么type是ref；当需要扫描的行数，使用idx2大约是idx1的5倍以上时，会用idx1，否则会用idx2
Extra:执行情况的描述和说明
•	Using filesort：MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。
•	Using temporary：使用了临时表保存中间结果，性能特别差，需要重点优化
•	Using index：表示相应的select操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，意味着无法直接通过索引查找来查询到符合条件的数据。
•	Using index condition：MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。
2.2 show profile分析
了解SQL执行的线程的状态及消耗的时。
默认是关闭的，开启语句set profiling = 1;
SHOW PROFILES;
SHOW PROFILES FOR QUERY #{id};
2.3 trace
trace分析优化器如何选择执行计划，通过trace文件能够进一步了解为什么优惠券选择A执行计划而不选择B执行计划。
Set optimizer_trace = "enabled=on";
Set optimizer_trace_max_mem_size = 1000000;
Select * from information_schema. optimizer_trace;
五、设计模式

